<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>深入理解 Monad | Pineislet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在函数式编程中，Monad 是一个重要的抽象概念。它为我们提供了一个更高的抽象层次来处理多态类型，在编码实践中有着广泛的应用。
然而，Monad 到底是什么，它能做什么，如何使用它？网上相关介绍的文章（尤其是中文）很少，而且其中大部分都是泛泛而谈，少部分又讳莫如深。这使得初次接触这个领域的人面临一个很高的学习门槛。">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 Monad">
<meta property="og:url" content="http://yasenia.github.io/2016/04/08/monad_in_deep/index.html">
<meta property="og:site_name" content="Pineislet">
<meta property="og:description" content="在函数式编程中，Monad 是一个重要的抽象概念。它为我们提供了一个更高的抽象层次来处理多态类型，在编码实践中有着广泛的应用。
然而，Monad 到底是什么，它能做什么，如何使用它？网上相关介绍的文章（尤其是中文）很少，而且其中大部分都是泛泛而谈，少部分又讳莫如深。这使得初次接触这个领域的人面临一个很高的学习门槛。">
<meta property="og:updated_time" content="2016-05-06T00:48:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解 Monad">
<meta name="twitter:description" content="在函数式编程中，Monad 是一个重要的抽象概念。它为我们提供了一个更高的抽象层次来处理多态类型，在编码实践中有着广泛的应用。
然而，Monad 到底是什么，它能做什么，如何使用它？网上相关介绍的文章（尤其是中文）很少，而且其中大部分都是泛泛而谈，少部分又讳莫如深。这使得初次接触这个领域的人面临一个很高的学习门槛。">
  
    <link rel="alternative" href="/atom.xml" title="Pineislet" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://r.loli.io/jMN7Jv.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Yasenia</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Yasenia" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/deng-yu-song-12" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/blog/" style="font-size: 20px;">blog</a> <a href="/tags/fp/" style="font-size: 10px;">fp</a> <a href="/tags/github/" style="font-size: 20px;">github</a> <a href="/tags/hexo/" style="font-size: 20px;">hexo</a> <a href="/tags/interview/" style="font-size: 10px;">interview</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/monad/" style="font-size: 10px;">monad</a> <a href="/tags/scala/" style="font-size: 10px;">scala</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Yasenia</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://r.loli.io/jMN7Jv.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Yasenia</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Yasenia" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/deng-yu-song-12" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-monad_in_deep" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/08/monad_in_deep/" class="article-date">
  	<time datetime="2016-04-08T04:14:54.000Z" itemprop="datePublished">2016-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入理解 Monad
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fp/">fp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/monad/">monad</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/scala/">scala</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在函数式编程中，Monad 是一个重要的抽象概念。它为我们提供了一个更高的抽象层次来处理多态类型，在编码实践中有着广泛的应用。</p>
<p>然而，Monad 到底是什么，它能做什么，如何使用它？网上相关介绍的文章（尤其是中文）很少，而且其中大部分都是泛泛而谈，少部分又讳莫如深。这使得初次接触这个领域的人面临一个很高的学习门槛。</p>
<a id="more"></a>
<p>关于 Monad，有这样一句广为流传的定义：</p>
<blockquote>
<p><em>A monad is just a monoid in the category of endofunctors, what’s the problem?</em></p>
</blockquote>
<p>对于 Wadler 这样的大神级人物而言，或许仅仅一句话就能解释 Monad 的本质，但对于大多数人而言，看到这样的定义只会更加的迷惑不解吧。</p>
<p>本文将基于 scala 语言，从范畴论的简单基础谈起，介绍 Monad 等概念的定义，进而讨论 Monad 与范畴论之间的联系。</p>
<p>目录：</p>
<ol>
<li><em>代数系统简介——半群、幺半群与群</em></li>
<li><em>Semigroup 与 Monoid 特质</em></li>
<li><em>Functor 特质</em></li>
<li><em>Applicative 特质</em></li>
<li><em>Monad 特质</em></li>
<li><em>Monad 与 Monoid 的联系</em></li>
</ol>
<h2 id="1-代数系统简介——半群、幺半群与群"><a href="#1-代数系统简介——半群、幺半群与群" class="headerlink" title="1. 代数系统简介——半群、幺半群与群"></a>1. 代数系统简介——半群、幺半群与群</h2><p>在正式讨论 Monad 及其相关概念之前，本文将先介绍一些基本的代数学知识进行铺垫。这并不需要你有范畴论、离散数学等相关方面的专业知识，只需要对下面几种概念有个大致的了解即可。</p>
<ul>
<li><p>半群(Semigroup)</p>
<blockquote>
<p>给定代数系统 $V =(S, ⊙)$，其中 $S$ 为非空集合，$⊙$ 为作用在 $S$ 上的二元运算。若对任意的 $a, b, c ∈ S$ ，总有 $a ⊙ b ∈ S$ 且 $(a ⊙ b) ⊙ c = a ⊙ (b ⊙ c)$。则称 $V$ 是一个半群。</p>
</blockquote>
</li>
<li><p>幺半群(Monoid)</p>
<blockquote>
<p>给定半群 $M = (S, ⊙)$。若存在 $e ∈ S$，对任意的 $x ∈ S$，总有 $e ⊙ x = x ⊙ e = e$。则称 $M$ 是一个幺半群,也记做 $M=(S, ⊙, e)$。</p>
</blockquote>
</li>
<li><p>群(Group)</p>
<blockquote>
<p>给定幺半群 $G = (S, ⊙, e)$。若对任意的 a ∈ S，总存在 $b ∈ S$，使得 $a ⊙ b = e$ 成立。则称 $G$ 是一个群。</p>
</blockquote>
</li>
</ul>
<p>下表对比了半群、幺半群与群所拥有的特性：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">半群(Semigroup)</th>
<th style="text-align:center">幺半群(Monoid)</th>
<th style="text-align:center">群(Group)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">封闭性</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">结合律</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">单位元</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">逆元</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<h2 id="2-Semigroup-与-Monoid-特质"><a href="#2-Semigroup-与-Monoid-特质" class="headerlink" title="2. Semigroup 与 Monoid 特质"></a>2. Semigroup 与 Monoid 特质</h2><p>根据半群与幺半群的定义，我们可以很容易的给出它们对应数据结构特质的实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Semigroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Semigroup</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> zero: <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于幺半群是一种特殊的半群（具有幺元的半群），因此在这里特质<code>Monoid</code>继承自特质<code>Semigroup</code>。</p>
<p>需要注意的是，在这里我们只是定义了两个代数系统对应的数据结构，这并不意味着所有实现了<code>Semigroup</code>(或<code>Monoid</code>)特质的类型就是半群（或幺半群）。以<code>Monoid</code>特质为例，我们仅在特质里定义了幺半群中的二元运算<code>op</code>与单位元<code>zero</code>的存在，但并不保证二元运算满足结合律且单位元满足不变性，即不能保证以下断言可以运行通过：</p>
<ul>
<li>结合律断言 <code>assert(m.op(m.op(a, b), c) == m.op(a, m.op(b, c)))</code></li>
<li>不变性断言 <code>assert(m.op(m.zero, a) == a &amp;&amp; m.op(a, m.zero) == a)</code></li>
</ul>
<p>这两点需要我们在具体实现的代码中书写正确的逻辑来确保。</p>
<p>这里给出几个<code>Monoid</code>的简单实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// M(Int, +, 0)</span></span><br><span class="line"><span class="keyword">val</span> intAdditionMonoid: <span class="type">Monoid</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Int</span>, a2: <span class="type">Int</span>): <span class="type">Int</span> = a1 + a2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// M(Int, *, 1)</span></span><br><span class="line"><span class="keyword">val</span> intProductMonoid: <span class="type">Monoid</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">Int</span>, a2: <span class="type">Int</span>): <span class="type">Int</span> = a1 * a2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// M(String, +, "")</span></span><br><span class="line"><span class="keyword">val</span> stringConcatMonoid: <span class="type">Monoid</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">String</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">String</span>, a2: <span class="type">String</span>): <span class="type">String</span> = a1 + a2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Functor-特质"><a href="#3-Functor-特质" class="headerlink" title="3. Functor 特质"></a>3. Functor 特质</h2><p>我们见过许多泛型类，如<code>List[A]</code>、<code>Option[A]</code>等。在大多数 Monad 相关的教程中，人们总是把这样的泛型类比喻成“盒子”，这个比喻当然很精妙，但也不总是那么贴切，不过在这里我们暂时沿用它。</p>
<p>假设我们有一个<code>F[A]</code>类型的数据，我们可以知道<code>F</code>这个盒子里的数据是<code>A</code>类型的（事实上并不一定是这样，准确的说应该是盒子的数据形态依赖于<code>A</code>，这也是为什么说“盒子”的比喻不总是贴切的），同时我们有一个函数<code>f: A =&gt; B</code>，它接收<code>A</code>类型的数据并返回<code>B</code>类型的数据。如果我们希望通过某种途径，基于<code>f: A =&gt; B</code>和<code>F[A]</code>得到一个新的数据结构<code>F[B]</code>，应该怎么做呢？</p>
<p>把大象放进冰箱只需要三步：打开冰箱 → 把大象放进去 → 关闭冰箱。我们的问题看上去复杂一些：打开盒子 → 取出a → 把a变成b → 把b放进盒子里 → 关上盒子。五步走可以解决吗？</p>
<p>事实上，在大多数情况下，我们并不关心变换是如何实现的，因为变换操作与具体的<code>F</code>类型有关。好的盒子我们甚至能“隔空取物”去改变它里面的数据，而一个不好的盒子，或许根本就无法实现这样的操作。我们需要关心的是，这个盒子，能否支持这样的操作。</p>
<p>对于一个<code>F</code>，如果我们能找到一个函数<code>map</code>，它接收<code>F[A]</code>和<code>f: A =&gt; B</code>作为参数并返回<code>F[B]</code>，并且当<code>f = a =&gt; a</code> 时，<code>map</code>函数返回值与接收的<code>F[A]</code>相同，则称这个<code>map</code>为类型<code>F</code>的函子(Functor)。</p>
<p>通过上面的定义，我们给出<code>Functor</code>特质的实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和前文中提到的<code>Semigroup</code>与<code>Monoid</code>一样，实现了特质<code>Functor[F]</code>并不等价于得到了一个<code>F</code>的函子，还需要<code>map</code>函数满足断言：<code>assert(map(fa)(a =&gt; a) == fa)</code>。</p>
<p>我们把所有的类型共同构成的集合称作一个范畴$C1$，每一个类型<code>x</code>对应的<code>F[x]</code>构成了另一个范畴$C2$。在范畴$C1$中，像<code>A =&gt; B</code>这样的类型转换被称作<code>A</code>到<code>B</code>类型的<em>态射</em>。可以看到，通过<code>F[_]</code>这样的类型构造器，我们可以将范畴$C1$中的<code>x</code>类型转换成范畴$C2$中的<code>F[x]</code>类型，而借助<code>Functor[F]</code>，我们可以将范畴$C1$中的<code>x =&gt; y</code>态射转换成范畴$C2$中的<code>F[x] =&gt; F[y]</code>态射。我们把这两种范畴$C1$到范畴$C2$的变换成为<em>函子变换</em>。<code>Functor</code>特质和<code>F[_]</code>的类型构造器共同组成了类型<code>F</code>上的函子（这也是为什么在部分书籍资料中，<code>Functor[F]</code>特质里还会有一个<code>A =&gt; F[A]</code>函数的原因，这个函数对应了<code>F[_]</code>的类型构造器）。</p>
<p>下面给出<code>Functor[List]</code>与<code>Functor[Option]</code>的实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listFunctor: <span class="type">Functor</span>[<span class="type">List</span>] = <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = as map f</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> optionFunctor: <span class="type">Functor</span>[<span class="type">Option</span>] = <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">Option</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](oa: <span class="type">Option</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] = oa map f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在<code>Functor</code>特质中定义一些基于<code>map</code>函数的衍生函数。这样，凡是具有<code>Functor[F]</code>实现的<code>F</code>类型数据，我们都可以用这些衍生函数来进行操作。下面给出了一个扩展了<code>distribute</code>函数的<code>Functor</code>特质：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] </span><br><span class="line">  <span class="comment">// 将 F[(A, B)] 类型数据分解成 F[A] 与 F[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">distribute</span></span>[<span class="type">A</span>, <span class="type">B</span>](fab: <span class="type">F</span>[(<span class="type">A</span>, <span class="type">B</span>)]): (<span class="type">F</span>[<span class="type">A</span>], <span class="type">F</span>[<span class="type">B</span>]) = (map(fab)(_._1), map(fab)(_._2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以使用<code>distribute</code>函数来处理<code>List</code>了（当然<code>Option</code>也一样）：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> pairList = <span class="type">List</span>((<span class="number">1</span>, <span class="string">"one"</span>), (<span class="number">2</span>, <span class="string">"two"</span>), (<span class="number">3</span>, <span class="string">"three"</span>))</span><br><span class="line">pairList: <span class="type">List</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">List</span>((<span class="number">1</span>,one), (<span class="number">2</span>,two), (<span class="number">3</span>,three))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> (intList, stringList) = listFunctor.distribute(pairList)</span><br><span class="line">intList: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">stringList: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(one, two, three)</span><br></pre></td></tr></table></figure>
<h2 id="4-Applicative-特质"><a href="#4-Applicative-特质" class="headerlink" title="4. Applicative 特质"></a>4. Applicative 特质</h2><p>函子(Functor)为我们处理抽象的泛型数据提供了一个有力的工具。通过定义基于<code>map</code>的衍生函数，让我们得到更高层次抽象出来的组合子(combinator)。然而，函子只要求实现了一个<code>map</code>函数，基于它我们虽然能衍生出许多实用的函数，但仍然有许多操作我们难以实现。</p>
<p>我们重新审视上一节中基于<code>map</code>得到的衍生函数<code>distribute</code>，这个函数接收了一个<code>F[(A, B)]</code>类型的参数并将其分解，返回<code>(F[A], F[B])</code>类型的数据。那么，我们能否编写一个新函数<code>combine</code>，将两个<code>F[A]</code>、<code>F[B]</code>类型的数据重新组合成<code>F[(A, B)]</code>类型的数据呢？我们先看看<code>combine</code>函数的签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[(<span class="type">A</span>, <span class="type">B</span>)]</span><br></pre></td></tr></table></figure>
<p>事实上，如果我们手上只有<code>Functor</code>特质中提供的<code>map</code>函数作为基础，是无法实现<code>combine</code>这样的函数的。<code>map</code>只提供了<code>F[A] =&gt; (A =&gt; B) =&gt; F[B]</code>这样一对一的映射函数，而解决我们的问题，则需要<code>(F[A], F[B]) =&gt; ((A, B) =&gt; C) =&gt; F[C]</code>这样二对一的映射函数。我们称它为<code>map2</code>，签名如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">F</span>[<span class="type">C</span>]</span><br></pre></td></tr></table></figure>
<p>基于<code>map2</code>，我们可以轻易的实现<code>combine</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[(<span class="type">A</span>, <span class="type">B</span>)] = map2(fa, fb)((_, _))</span><br></pre></td></tr></table></figure>
<p>现在，我们手上拥有了<code>map</code>和<code>map2</code>两样“原料”，它们之间有什么区别和联系呢？事实上，<code>map2</code>函数比<code>map</code>函数更为强大，因为我们可以基于<code>map2</code>函数来实现<code>map</code>，而反过来却不可以！</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = map2(fa, fa)((a, _) =&gt; f(a))</span><br></pre></td></tr></table></figure>
<p>这里，我们给出一个继承自<code>Functor</code>特质的<code>PowerfulFunctor</code>，在这个新特质中，我们定义了<code>map2</code>函数，并用它重写了<code>map</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PowerfulFunctor</span>[<span class="type">F</span>[_]] <span class="keyword">extends</span> <span class="title">Functor</span>[<span class="type">F</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = map2(fa, fa)((a, _) =&gt; f(a))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">F</span>[<span class="type">C</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现<code>PowerfulFunctor</code>，只需要实现<code>map2</code>函数即可，对于具有<code>PowerfulFunctor</code>的类型<code>F</code>，我们除了可以进行<code>Functor[F]</code>所提供的操作外，还可以基于<code>map2</code>函数实现更多的功能（比如<code>combine</code>函数等）。</p>
<p>可以看到，<code>PowerfulFunctor</code>特质比<code>Functor</code>特质要强大。但在实际中，仍然有许多操作，仅仅通过<code>map2</code>函数是无法实现的。</p>
<p>重新回到我们把<code>F</code>比作盒子的假说，考虑一件最简单的事情：怎样把数据放到这个盒子里去？对<code>F</code>进行操作，要通过一个<code>A</code>类型的数据来得到一个<code>F[A]</code>类型的数据似乎是一件再普遍不过的操作了。然而就是这个简单的操作，无论是<code>Functor</code>或是更强大的<code>PowerfulFunctor</code>都无法办到。这里我们需要一个简单的打包函数，签名如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure>
<p>现在，我们重新定义一个名为<code>Applicative</code>的特质，该特质定义了<code>unit</code>与<code>map2</code>函数，我们知道，<code>Applicative</code>是一个更为强大的<code>Functor</code>，可以看做是<code>Functor</code>的一个拓展，因此，我们让<code>Applicative</code>继承自<code>Functor</code>，并在其中实现了一个基于<code>unit</code>与<code>map2</code>函数衍生出来的函数<code>sequence</code>:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Applicative</span>[<span class="type">F</span>[_]] <span class="keyword">extends</span> <span class="title">Functor</span>[<span class="type">F</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = map2(fa, unit(()))((a, _) =&gt; f(a))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">F</span>[<span class="type">C</span>]</span><br><span class="line">  <span class="comment">// 将 List[F[A]] 类型数据重组成 F[List[A]]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sequence</span></span>[<span class="type">A</span>](fas: <span class="type">List</span>[<span class="type">F</span>[<span class="type">A</span>]]): <span class="type">F</span>[<span class="type">List</span>[<span class="type">A</span>]] = fas.foldRight(unit(<span class="type">List</span>.empty[<span class="type">A</span>]))(map2(_, _)(_ :: _))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>Option</code>为例，我们给出<code>Applicative[Option]</code>的实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> optionApplicative: <span class="type">Applicative</span>[<span class="type">Option</span>] = <span class="keyword">new</span> <span class="type">Applicative</span>[<span class="type">Option</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">Option</span>[<span class="type">A</span>] = <span class="type">Some</span>(a)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">Option</span>[<span class="type">A</span>], fb: <span class="type">Option</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">Option</span>[<span class="type">C</span>] = <span class="keyword">for</span> &#123;</span><br><span class="line">    a &lt;- fa</span><br><span class="line">    b &lt;- fb</span><br><span class="line">  &#125; <span class="keyword">yield</span> f(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们在 REPL 中测试一下<code>Applicative</code>为我们提供的<code>sequence</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> optionList1 = <span class="type">List</span>(<span class="type">Some</span>(<span class="string">"Functor"</span>), <span class="type">Some</span>(<span class="string">"Applicative"</span>), <span class="type">Some</span>(<span class="string">"Monad"</span>))</span><br><span class="line">optionList1: <span class="type">List</span>[<span class="type">Some</span>[<span class="type">String</span>]] = <span class="type">List</span>(<span class="type">Some</span>(<span class="type">Functor</span>), <span class="type">Some</span>(<span class="type">Applicative</span>), <span class="type">Some</span>(<span class="type">Monad</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> optionList2 = <span class="type">List</span>(<span class="type">Some</span>(<span class="string">"Semigroup"</span>), <span class="type">Some</span>(<span class="string">"Monoid"</span>), <span class="type">None</span>)</span><br><span class="line">optionList2: <span class="type">List</span>[<span class="type">Option</span>[<span class="type">String</span>]] = <span class="type">List</span>(<span class="type">Some</span>(<span class="type">Semigroup</span>), <span class="type">Some</span>(<span class="type">Monoid</span>), <span class="type">None</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; optionApplicative.sequence(optionList1)</span><br><span class="line">res0: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">String</span>]] = <span class="type">Some</span>(<span class="type">List</span>(<span class="type">Functor</span>, <span class="type">Applicative</span>, <span class="type">Monad</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; optionApplicative.sequence(optionList2)</span><br><span class="line">res1: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">String</span>]] = <span class="type">None</span></span><br></pre></td></tr></table></figure>
<h2 id="5-Monad-特质"><a href="#5-Monad-特质" class="headerlink" title="5. Monad 特质"></a>5. Monad 特质</h2><p><code>Applicative</code>特质无疑比<code>Functor</code>特质为我们实现更多更强大的函数提供了更好的基础，然而它依旧有那么一点缺陷。</p>
<p>假设我们有一个被<code>F</code>类型包装的数据<code>fa: F[A]</code>，一个函数<code>f: A =&gt; F[B]</code>，如果执行<code>map(fa)(f)</code>操作，我们将得到一个<code>F[F[A]]</code>类型的对象。在很多情况下，这个结果或许并不是我们想要的，比如一个<code>Option[Option[A]]</code>。我们不想一层层的去打开这个盒子然后看看里面到底装了什么，只想要一个单层的<code>Option[A]</code>。</p>
<p>在这种场景下，我们需要这样的一个函数<code>flatMap</code>，它的签名如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure>
<p>我们已经在<code>Applicative</code>特质定义了两个函数<code>unit</code>和<code>map2</code>，现在是不是意味着我们需要再往里面添砖加瓦，新增一个<code>flatMap</code>呢？其实我们可以看到，有了<code>flatMap</code>之后，<code>map2</code>函数已经是多余的了，我们可以用<code>unit</code>函数与<code>flatMap</code>函数来实现<code>map2</code>:</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">F</span>[<span class="type">C</span>] = flatMap(fa)(a =&gt; flatMap(fb)(b =&gt; unit(f(a, b))))</span><br></pre></td></tr></table></figure>
<p>现在，我们可以重新定义一个特质，它继承自<code>Applicative</code>特质，定义了一个新的<code>flatMap</code>函数，并且实现了<code>Applicative</code>特质中的<code>map2</code>函数。这个特质，就是<code>Monad</code>，下面给出了<code>Monad</code>特质的实现，并在其中添加了一个基于<code>flatMap</code>衍生的函数<code>compose</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] <span class="keyword">extends</span> <span class="title">Applicative</span>[<span class="type">F</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">F</span>[<span class="type">C</span>] = flatMap(fa)(a =&gt; flatMap(fb)(b =&gt; unit(f(a, b))))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>], g: <span class="type">B</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]): <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">C</span>] = a =&gt; flatMap(f(a))(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以实现一个<code>Monad[List]</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listMonad: <span class="type">Monad</span>[<span class="type">List</span>] = <span class="keyword">new</span> <span class="type">Monad</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">List</span>[<span class="type">A</span>] = <span class="type">List</span>(a)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: (<span class="type">A</span>) =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>] = as flatMap f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 REPL 中测试<code>Monad</code>提供的<code>compose</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> f: <span class="type">String</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>] = s =&gt; s.toList.map(_.toString.toInt)</span><br><span class="line">f: <span class="type">String</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> g: <span class="type">Int</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>] = n =&gt; <span class="type">List</span>.fill(n)(n)</span><br><span class="line">g: <span class="type">Int</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> h = listMonad.compose(f, g)</span><br><span class="line">h: <span class="type">String</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>] = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; h(<span class="string">"123"</span>)</span><br><span class="line">res1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-Monad-与-Monoid"><a href="#6-Monad-与-Monoid" class="headerlink" title="6. Monad 与 Monoid"></a>6. Monad 与 Monoid</h2><p>早在第1、2节中，我们就介绍过幺半群的概念并给出了一个<code>Monoid</code>特质。相信每一位FP的初学者都会心存疑问：Monad 和 Monoid，这两者之间到底有什么联系？它们的名字如此相似，难道只是巧合吗？</p>
<p>通过前面的介绍，我们知道，对于<code>F</code>类型而言，Monad 是由定义在<code>F</code>上的两个基本函数<code>unit</code>与<code>flatMap</code>共同组成的。</p>
<p>上一节中，我们在<code>Monad</code>特质里基于<code>flatMap</code>实现了一个<code>compose</code>函数。仔细研究一下<code>compose</code>就会发现，我们也可以通过<code>compose</code>函数来实现<code>flatMap</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>] = compose((_ : <span class="type">Unit</span>) =&gt; fa, f)(())</span><br></pre></td></tr></table></figure>
<p>这意味着，<code>compose</code>函数与<code>flatMap</code>函数是等价的。我们完全可以用<code>compose</code>函数来取代<code>faltMap</code>函数，并基于<code>unit</code>函数与<code>compose</code>函数衍生出<code>flatMap</code>、<code>map2</code>、<code>map</code>以及更多其它的函数。我们得到一个 Monad 的等价定义，这里给出<code>MonadEq</code>特质的实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MonadEq</span>[<span class="type">F</span>[_]] <span class="keyword">extends</span> <span class="title">Applicative</span>[<span class="type">F</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](a: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](fa: <span class="type">F</span>[<span class="type">A</span>], fb: <span class="type">F</span>[<span class="type">B</span>])(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">C</span>): <span class="type">F</span>[<span class="type">C</span>] = flatMap(fa)(a =&gt; flatMap(fb)(b =&gt; unit(f(a, b))))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>], g: <span class="type">B</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]): <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](fa: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>] = compose((_ : <span class="type">Unit</span>) =&gt; fa, f)(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>MonadEq</code>与<code>Monad</code>特质具有同样强大的功能。所有我们通过<code>Monad</code>能完成的操作，都可以通过<code>MonadEq</code>来实现。</p>
<p>我们把<code>MonadEq</code>特质中多余的衍生函数去掉，不再令其继承自<code>Applicative</code>特质，并将<code>unit</code>函数与<code>compose</code>函数稍加变形，得到一个新的特质<code>Mon</code>如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mon</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> unit[<span class="type">A</span>]: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compose</span></span>[<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>](f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>], g: <span class="type">B</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]): <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">C</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是感觉到很眼熟？再看看我们的<code>Monoid</code>特质（为了方便比较，这里不再让<code>Monoid</code>特质继承自<code>Semigroup</code>特质）：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> zero: <span class="type">A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>Mon</code>中的<code>unit</code>和<code>compose</code>函数极好的吻合了<code>Monoid</code>中的<code>zero</code>与<code>op</code>！</p>
<p>现在我们再重新理解 Wadler 说过的那句关于 Monad 的定义：</p>
<blockquote>
<p>“Monad 不过是一个自函子范畴上的幺半群而已，有什么问题吗？”</p>
</blockquote>
<p><code>A =&gt; F[B]</code>正是一个从范畴$C1$到范畴$C2$的函子变换。当我们把这样的函子变换构成的集合看做一个新的范畴$C$时，可以非常明显的看出来，<code>Monad[F]</code>就是范畴$C$上的幺半群！</p>
<p>把 <code>Monad[F]</code> 看成以一个幺半群$M = (S, ⊙, e)$，在这个幺半群中，$S$为所有形如<code>A =&gt; F[B]</code>的函数构成的集合；二元运算$⊙$为<code>compose</code>函数；单位元$e$就是<code>zero</code>。<br>此时，幺半群的二元运算结合律与单位元的不变性表现为以下断言：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">assert(m.compose(m.compose(f, g), h) == m.compose(f, m.compose(g, h)))</span><br><span class="line">assert(m.compose(f, m.unit) == f)</span><br><span class="line">assert(m.compose(m.unit, f) == f)</span><br></pre></td></tr></table></figure>
<p>理解了这些，关于函子(functor)与单子(monad)的概念，我们是不是也能有自信的说出一句：“What’s the problem?”</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/05/java-interview-question/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          原创 Java 面试题
        
      </div>
    </a>
  
  
    <a href="/2016/01/25/build-blog-with-hexo-02/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">使用 hexo 搭建个人博客 02</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="monad_in_deep" data-title="深入理解 Monad" data-url="http://yasenia.github.io/2016/04/08/monad_in_deep/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Yasenia
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>







<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>